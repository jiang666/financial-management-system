### 后端开发技术约束文档（V2.0）

#### 1. 文档目的
本文档定义了团队在后端开发中的技术约束和约定，用于指导AI辅助开发过程。所有开发工作必须严格遵守这些约束，以确保代码一致性、可维护性和团队协作效率。AI在生成代码、设计架构或提供建议时，必须优先参考本文档内容。如果需求涉及禁用技术或超出约束范围，AI应暂停并请求确认。

#### 2. 技术栈
- **核心框架**：使用Spring Boot作为主要后端框架。所有新项目必须基于Spring Boot启动，确保快速开发和单体应用架构支持（团队项目大多数为单体应用）。
- **数据访问层**：采用Spring Data JPA作为ORM框架。实体类、Repository接口和数据操作必须通过Spring Data JPA实现，避免直接使用JDBC或原生SQL，除非在性能优化场景下经团队确认。
- **安全框架**：集成Spring Security处理认证、授权和安全相关功能。默认使用JWT（JSON Web Token）作为令牌机制，支持OAuth2如果项目需要外部认证。
- **其他依赖**：
  - 日志：使用SLF4J + Logback，统一使用@Slf4j注解打印日志。
  - 异常处理：统一使用自定义ExceptionHandler处理全局异常。
  - 依赖管理：通过Maven管理，确保版本一致（使用Spring Boot的BOM）。
- **AI/向量相关集成**：当项目需要对接大语言模型（LLM）时，使用Python开发独立服务暴露对外访问接口（如REST API），然后在Java代码中通过HTTP客户端（如RestTemplate或WebClient）调用该Python服务。避免在Java中直接处理向量操作。

#### 3. 数据库选择
- **默认数据库**：99%的情况下使用MySQL作为关系型数据库。优先选择MySQL 8.x版本，支持InnoDB引擎。
- **特殊场景**：如果项目涉及AI相关的向量数据存储（如嵌入式向量、相似性搜索），则切换使用PostgreSQL（推荐版本14.x或更高），并集成PGVector扩展以支持向量操作。该场景通常与对接大语言模型结合，实际向量处理通过Python服务实现，Java仅负责调用。
- **数据库交互**：
  - 使用Flyway或Liquibase进行数据库迁移和版本控制。
  - 避免直接在代码中硬编码SQL查询；优先使用JPA的Query方法或Specification。
  - 数据备份和恢复：所有项目必须集成数据库备份机制（如定时任务）。

#### 4. 编码规范
- **命名约定**：
  - 类名：使用PascalCase（例如：UserService）。实体类名以数据库表名去掉前缀后转为驼峰命名（如tb_user_info -> UserInfo）。
  - 方法名和变量名：使用camelCase（例如：getUserById）。
  - 常量：使用UPPER_CASE（例如：MAX_RETRY_COUNT）。
  - 包结构：com.company.project.module（例如：com.example.user.service）。
- **代码风格**：
  - 符合公认的Java编码规范（如Oracle Java代码约定）：缩进使用4个空格（禁用Tab），行长度不超过120字符，避免不必要的空白行。
  - 注释：使用Javadoc风格注释关键方法和类；避免冗余注释。实体类、Service和Controller的公共方法必须包含Javadoc注释，以便手动生成接口文档。
  - 错误处理：所有方法必须抛出或捕获异常，不允许忽略异常。
- **REST API设计**：
  - 使用RESTful风格：GET/POST/PUT/DELETE等标准HTTP方法。
  - 响应格式：统一使用JSON，返回结构包括code、message、data。推荐使用ResponseEntity和ResponsePageDataEntity（若存在）包装返回值。
  - 版本控制：通过URL路径（如/v1/users）或Header实现API版本化。
- **性能与优化**：
  - 缓存：禁用Redis（见禁用技术）。如需缓存，使用Spring Boot内置的ConcurrentMapCacheManager或Ehcache。
  - 异步处理：使用@Async注解或TaskExecutor处理非阻塞任务。
- **开发环境**：所有开发工作在Windows 10或11系统上进行，确保代码兼容Windows环境（如路径分隔符使用/以兼容跨平台）。

#### 5. Spring Data JPA特定约束
- **实体类设计**：
  - **必含字段**：每个实体类必须包含以下字段：
    - `id`：String类型，使用UUID生成（推荐使用`UUID.randomUUID().toString()`）。
    - `createTime`：Long类型，存储时间戳（毫秒），表示记录创建时间。
    - `updateTime`：Long类型，存储时间戳（毫秒），表示记录最后更新时间。
    - `createBy`：String类型，存储创建人（当前登录系统的账号）。
    - `updateBy`：String类型，存储更新人（当前登录系统的账号）。
  - **主键生成**：主键`id`必须为String类型，使用UUID生成，不允许使用自增ID或其他策略。
  - **时间字段**：所有涉及时间的属性必须使用Long类型时间戳（毫秒），禁止使用`Date`、`LocalDateTime`或其他时间类型。
  - **外键与关系**：
    - 禁用JPA关系注解（如`@OneToMany`、`@ManyToOne`、`@OneToOne`、`@ManyToMany`）。
    - 外键字段作为普通属性处理（如String或Long），不使用`@JoinColumn`或其他外键注解。
    - 如需关联查询，使用JPA的`JOIN`操作或手动在Service层处理关联逻辑。
- **注解限制**：
  - 实体类上只允许使用以下注解，非必须情况下禁止添加其他注解：
    - `@Entity`：标记实体类。
    - `@Data`：lombok注解。
    - `@Table`：指定数据库表名。
    - `@NoArgsConstructor`：提供无参构造器（通过Lombok）。
    - `@AllArgsConstructor`：提供全参构造器（通过Lombok）。
  - 字段上只允许使用必要注解（如`@Id`、`@Column`），其他注解（如`@Temporal`、`@JoinColumn`）一律禁用。
- **示例实体类**：
  ```java
  import javax.persistence.Entity;
  import javax.persistence.Id;
  import javax.persistence.Table;
  import javax.persistence.Column;
  import lombok.*;
  
@Entity
  @Table(name = "tb_user_info")
  @NoArgsConstructor
  @AllArgsConstructor
  @Data
  public class UserInfo {
      @Id
      @Column(name = "id")
      private String id;

      @Column(name = "create_time")
      private Long createTime;

      @Column(name = "update_time")
      private Long updateTime;

      @Column(name = "create_by")
      private String createBy;

      @Column(name = "update_by")
      private String updateBy;

      @Column(name = "username")
      private String username;

      @Column(name = "role_id") // 外键作为普通字段
      private String roleId;
}
  ```
- **Repository设计**：
  - 使用`JpaRepository`或`PagingAndSortingRepository`作为基础接口。
  - 查询方法优先使用JPA的命名查询或`@Query`注解，避免复杂原生SQL。
  - 分页查询使用`Pageable`和`Page`返回符合ResponsePageDataEntity格式的结果。
- **数据初始化**：
  - `id`：在Service层使用`UUID.randomUUID().toString()`生成。
  - `createTime`和`updateTime`：在保存实体时，使用`System.currentTimeMillis()`设置。
  - `createBy`和`updateBy`：从Spring Security的`SecurityContextHolder`获取当前登录账号（如`Authentication.getName()`）。

#### 6. 安全实践
- **认证与授权**：所有API必须通过Spring Security保护。默认启用CSRF保护（Web应用）和CORS配置。
- **数据加密**：敏感数据（如密码）使用BCrypt或Argon2哈希存储；传输层使用HTTPS。
- **输入验证**：使用Bean Validation（@NotNull、@Size等）校验请求参数。
- **日志安全**：避免在日志中记录敏感信息（如密码、Token）。

#### 7. 测试与部署
- **测试**：采用人工测试方法，确保功能、性能和安全符合要求。没有使用任何自动化测试工具（如JUnit），测试过程由开发人员手动执行和验证。
- **部署**：
  - 环境：部署到自建服务器，大多数使用Windows系统，但有时为Linux系统。确保应用兼容两者（如使用跨平台路径处理）。
  - 方式：打包为JAR文件，通过Maven构建后手动或脚本部署到服务器。推荐使用Docker容器化以简化跨平台部署，如果项目需要。
  - 监控：集成Spring Boot Actuator监控应用健康；手动检查日志和性能指标。

#### 8. 禁用技术
- **禁用技术列表**：
  - **Swagger/OpenAPI**：
    - **原因**：团队不希望依赖外部工具生成API文档，优先手动维护以减少配置复杂性和学习成本。
    - **替代方案**：手动编写API文档（如Markdown、Word或Confluence），包含接口URL、方法、参数、返回值及示例。AI生成代码时，应附带Javadoc注释或单独的文档文件。
  - **MyBatis及MyBatis-Plus**：
    - **原因**：与Spring Data JPA相比，配置复杂，SQL编写容易出错，团队更熟悉JPA。
    - **替代方案**：使用Spring Data JPA，结合JPA的Query方法或Criteria API处理复杂查询。如需原生SQL，需经团队审批并记录。
  - **Redis**：
    - **原因**：减少外部依赖，降低服务器维护成本，避免配置和部署复杂性。
    - **替代方案**：使用Spring Boot内置的ConcurrentMapCacheManager或Ehcache。如需分布式缓存，需经团队讨论并更新文档。
- **AI辅助开发规则**：AI在生成代码或建议时，必须检查是否涉及禁用技术（Swagger、MyBatis、MyBatis-Plus、Redis）。如果检测到禁用技术，AI应：
  1. 停止生成相关代码。
  2. 提示禁用技术的使用并建议替代方案（如JPA替代MyBatis、Ehcache替代Redis）。
  3. 请求团队确认是否允许临时使用禁用技术或调整约束。

#### 9. 其他约束
- **版本控制**：使用Git作为VCS，分支策略采用Git Flow（main/develop/feature/bugfix）。
- **文档生成**：禁用Swagger，API文档需手动编写，使用Markdown、Word或Confluence，包含接口URL、方法、参数、返回值及示例。
- **第三方库**：引入新库前必须经团队审查，避免引入不必要的依赖。
- **AI辅助开发特定规则**：AI生成代码时，必须：
  - 输出符合本约束的完整代码片段（如实体类包含必含字段，仅使用允许的注解）。
  - 标注潜在风险或优化点（如性能瓶颈、跨平台兼容性）。
  - 如果需求涉及未定义的技术或禁用技术，暂停并请求确认。
