# 后端技术栈约束提示词

## 🔧 后端技术栈约束规范

### 必须使用的核心技术栈

```
请严格使用以下后端技术栈进行开发，不得使用禁用清单中的技术：

## 核心框架 (必须使用)
- Spring Boot (主框架)
- Spring Data JPA (关系型数据库持久层)
- Spring Data MongoDB (MongoDB持久层)
- Spring Security (权限认证)
- Lombok (简化代码注解)
- @Slf4j (日志注解) 
- Python (AI相关功能)

## 数据库约束 (仅限以下三种)
1. **MySQL** - 主要业务数据存储
2. **MongoDB** - 文档型数据存储
3. **PostgreSQL** - AI向量数据存储 (pgvector扩展)

## 必用注解规范
1. @Slf4j - 所有类必须使用此日志注解
2. Lombok注解族：
   - @Data (getter/setter/toString/equals/hashCode)
   - @Entity (JPA实体)
   - @Document (MongoDB文档)
   - @NoArgsConstructor / @AllArgsConstructor
   - @Builder (建造者模式)
   - @Value (不可变对象)

## 数据访问层约束
- MySQL：使用Spring Data JPA，Repository继承JpaRepository
- MongoDB：使用Spring Data MongoDB，Repository继承MongoRepository
- PostgreSQL：使用Spring Data JPA + pgvector，用于AI向量存储
- 自定义查询使用@Query注解
- 实体关系使用JPA注解(@OneToMany, @ManyToOne等)

## 实体类规范 (必须遵守)
### MySQL实体类 (JPA)
- 必须有UUID类型的主键id
- 使用@Entity和@Table注解
- 示例：
​```java
@Entity
@Table(name = "users")
@Data
public class User {
    @Id
    @GeneratedValue(generator = "uuid")
    @GenericGenerator(name = "uuid", strategy = "uuid2")
    private String id; // 必须为UUID类型
    
    private String username;
    // 其他字段...
}
```

### MongoDB文档类

- 必须有UUID类型的主键id
- 使用@Document注解
- 示例：

```java
@Document(collection = "logs")
@Data
public class LogDocument {
    @Id
    private String id; // MongoDB自动生成ObjectId，转为String
    
    private String content;
    private Date timestamp;
    // 其他字段...
}
```

### PostgreSQL向量实体类 (AI相关)

- 用于存储AI向量数据
- 支持pgvector扩展
- 示例：

```java
@Entity
@Table(name = "embeddings")
@Data
public class Embedding {
    @Id
    @GeneratedValue(generator = "uuid")
    @GenericGenerator(name = "uuid", strategy = "uuid2")
    private String id;
    
    @Column(name = "vector", columnDefinition = "vector(1536)")
    private String vector; // 向量数据
    
    private String content; // 原始内容
    // 其他字段...
}
```

## 接口返回值规范 (必须使用)

- 所有接口必须使用统一的ResponseEntity<T>返回
- 分页查询必须使用ResponsePageDataEntity<T>
- 返回格式：

```java
// 成功响应
return ResponseEntity.success(data);

// 失败响应  
return ResponseEntity.fail("错误信息");

// 分页响应
ResponsePageDataEntity<User> pageData = new ResponsePageDataEntity<>();
pageData.setTotal(total);
pageData.setRows(userList);
return ResponseEntity.success(pageData);
```

## 权限安全约束

- 必须使用Spring Security
- JWT Token认证方式
- 角色权限控制使用@PreAuthorize注解
- 密码加密使用BCryptPasswordEncoder

## AI功能约束

- Python脚本处理AI相关业务
- Java调用Python通过ProcessBuilder或RestTemplate
- AI模型推理结果通过JSON格式交互

```
---

## ❌ 严禁使用技术清单
```

以下技术严禁在项目中使用：

## 文档工具 (禁用)

❌ Swagger / OpenAPI (任何版本) ❌ Knife4j ❌ SpringDoc ❌ 任何API文档生成工具

## 缓存技术 (禁用)

❌ Redis (任何用途) ❌ Ehcache ❌ Caffeine ❌ Hazelcast ❌ 其他缓存中间件

## 持久层框架 (禁用)

❌ MyBatis (包括MyBatis-Plus) ❌ MyBatis Generator ❌ 任何SQL映射框架 ❌ Hibernate原生API (只能用Spring Data JPA封装)

## 其他禁用技术

❌ Shiro (权限框架，必须用Spring Security) ❌ Druid连接池配置页面 ❌ 其他非Spring生态的框架

```
---

## 📋 标准项目结构约束
```

src/main/java/com/company/project/ ├── controller/          # REST接口层 ├── service/            # 业务逻辑层
 ├── repository/         # 数据访问层(JPA) ├── entity/            # JPA实体类 ├── dto/               # 数据传输对象 ├── config/            # 配置类 ├── security/          # Spring Security配置 ├── exception/         # 异常处理 ├── util/              # 工具类 ├── ai/                # AI相关功能(调用Python) └── common/            # 通用类(ResponseEntity等)

src/main/resources/ ├── application.yml     # 配置文件 ├── data.sql           # 初始化数据 └── python/            # Python AI脚本

src/main/python/       # Python AI模块 ├── models/            # AI模型 ├── services/          # AI业务逻辑 └── utils/             # Python工具

```
---

## 🎯 代码规范约束

### 必须的注解使用
​```java
// 1. MySQL实体类和Repository
@Data
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(generator = "uuid")
    @GenericGenerator(name = "uuid", strategy = "uuid2")
    private String id;
    
    private String username;
    private String email;
}

public interface UserRepository extends JpaRepository<User, String> {
    @Query("SELECT u FROM User u WHERE u.status = :status")
    List<User> findByStatus(@Param("status") String status);
}

// 2. MongoDB文档类和Repository
@Data
@Document(collection = "system_logs")
public class SystemLog {
    @Id
    private String id;
    
    private String level;
    private String message;
    private Date timestamp;
}

public interface SystemLogRepository extends MongoRepository<SystemLog, String> {
    List<SystemLog> findByLevelAndTimestampBetween(
        String level, Date start, Date end);
}

// 3. PostgreSQL向量实体类 (AI相关)
@Data
@Entity
@Table(name = "document_embeddings")
public class DocumentEmbedding {
    @Id
    @GeneratedValue(generator = "uuid")
    @GenericGenerator(name = "uuid", strategy = "uuid2")
    private String id;
    
    @Column(name = "vector", columnDefinition = "vector(1536)")
    private String vector;
    
    private String documentId;
    private String content;
}

public interface DocumentEmbeddingRepository extends JpaRepository<DocumentEmbedding, String> {
    @Query(value = "SELECT * FROM document_embeddings ORDER BY vector <-> CAST(?1 AS vector) LIMIT ?2", 
           nativeQuery = true)
    List<DocumentEmbedding> findSimilarVectors(String queryVector, int limit);
}

// 4. Controller使用不同数据源
@RestController
@RequestMapping("/api")
@Slf4j
public class DataController {
    
    @Autowired
    private UserRepository userRepository; // MySQL
    
    @Autowired
    private SystemLogRepository logRepository; // MongoDB
    
    @Autowired
    private DocumentEmbeddingRepository embeddingRepository; // PostgreSQL
    
    @GetMapping("/users")
    public ResponseEntity<List<User>> getUsers() {
        List<User> users = userRepository.findAll();
        return ResponseEntity.success(users);
    }
    
    @GetMapping("/logs")
    public ResponseEntity<List<SystemLog>> getLogs() {
        List<SystemLog> logs = logRepository.findAll();
        return ResponseEntity.success(logs);
    }
    
    @PostMapping("/search-similar")
    public ResponseEntity<List<DocumentEmbedding>> searchSimilar(@RequestBody String vector) {
        List<DocumentEmbedding> similar = embeddingRepository.findSimilarVectors(vector, 10);
        return ResponseEntity.success(similar);
    }
}
### 日志规范
​```java
// 必须使用@Slf4j，禁用System.out.println
@Slf4j
@Service
public class BusinessService {
    
    public void processData() {
        log.info("开始处理业务数据");
        try {
            // 业务逻辑
            log.debug("处理详细信息：{}", details);
        } catch (Exception e) {
            log.error("处理失败：{}", e.getMessage(), e);
        }
        log.info("业务数据处理完成");
    }
}
```

### AI功能集成规范

```java
// Java调用Python AI服务的标准方式
@Service
@Slf4j
public class AIService {
    
    @Autowired
    private DocumentEmbeddingRepository embeddingRepository;
    
    /**
     * 文本向量化并存储到PostgreSQL
     */
    public void generateAndStoreEmbedding(String content, String documentId) {
        try {
            // 调用Python服务生成向量
            String vector = callPythonEmbeddingService(content);
            
            // 存储到PostgreSQL
            DocumentEmbedding embedding = new DocumentEmbedding();
            embedding.setContent(content);
            embedding.setDocumentId(documentId);
            embedding.setVector(vector);
            
            embeddingRepository.save(embedding);
            log.info("向量存储完成：documentId={}", documentId);
            
        } catch (Exception e) {
            log.error("向量化处理失败：{}", e.getMessage(), e);
            throw new AIProcessException("向量化处理异常", e);
        }
    }
    
    /**
     * 语义搜索
     */
    public List<DocumentEmbedding> semanticSearch(String query, int limit) {
        try {
            // 将查询文本向量化
            String queryVector = callPythonEmbeddingService(query);
            
            // 在PostgreSQL中进行向量相似度搜索
            List<DocumentEmbedding> results = embeddingRepository
                .findSimilarVectors(queryVector, limit);
                
            log.info("语义搜索完成，返回{}条结果", results.size());
            return results;
            
        } catch (Exception e) {
            log.error("语义搜索失败：{}", e.getMessage(), e);
            throw new AIProcessException("语义搜索异常", e);
        }
    }
    
    private String callPythonEmbeddingService(String text) {
        // 方式1：通过HTTP调用Python服务
        ResponseEntity<String> response = restTemplate.postForEntity(
            "http://ai-service:8080/embedding", text, String.class);
        return response.getBody();
    }
}
```

------

## 🔒 安全配置约束

```java
// Spring Security配置示例
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
@Slf4j
public class SecurityConfig {
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint() {
        return new JwtAuthenticationEntryPoint();
    }
    
    // JWT配置...
}
```

------

## 📝 完整开发提示词模板

```
【后端技术约束】
必须使用：Spring Boot + Spring Data JPA + Spring Data MongoDB + Spring Security + Lombok + @Slf4j + Python(AI)
数据库限制：仅限MySQL(业务数据) + MongoDB(文档数据) + PostgreSQL(AI向量数据)
严禁使用：Swagger文档、Redis缓存、MyBatis系列、Shiro权限框架

【代码规范】
- 所有类必须使用@Slf4j日志注解
- MySQL实体：@Entity + @Table，UUID主键，JpaRepository<Entity, String>
- MongoDB文档：@Document，MongoRepository<Document, String>
- PostgreSQL向量：@Entity，pgvector扩展，向量相似度搜索
- 权限控制使用@PreAuthorize注解
- AI功能：Java调用Python向量化服务，存储到PostgreSQL

【接口返回值规范】
- 所有接口必须使用ResponseEntity<T>统一返回格式
- 成功：ResponseEntity.success(data)
- 失败：ResponseEntity.fail("错误信息")
- 分页：ResponseEntity.success(ResponsePageDataEntity<T>)

【数据库使用场景】
- MySQL：用户、权限、业务核心数据
- MongoDB：日志、文档、非结构化数据
- PostgreSQL：AI向量、语义搜索、机器学习特征

【AI集成】
Java通过RestTemplate调用Python向量化服务，向量数据存储PostgreSQL进行相似度搜索
```

------

## ✅ 开发检查清单

**技术栈检查：**

- [ ] 使用Spring Boot框架
- [ ] MySQL使用Spring Data JPA
- [ ] MongoDB使用Spring Data MongoDB
- [ ] PostgreSQL使用Spring Data JPA + pgvector
- [ ] 权限使用Spring Security
- [ ] 所有类使用@Slf4j注解

**数据库实体检查：**

- [ ] MySQL实体使用@Entity + UUID主键
- [ ] MongoDB文档使用@Document注解
- [ ] PostgreSQL向量实体支持pgvector
- [ ] Repository选择正确类型(JpaRepository/MongoRepository)

**接口规范检查：**

- [ ] 所有接口使用ResponseEntity<T>返回
- [ ] 分页查询使用ResponsePageDataEntity<T>
- [ ] 成功响应使用ResponseEntity.success()
- [ ] 失败响应使用ResponseEntity.fail()

**AI功能检查：**

- [ ] 向量数据存储到PostgreSQL
- [ ] Java通过RestTemplate调用Python服务
- [ ] 向量相似度搜索使用pgvector
- [ ] AI相关异常正确处理

**禁用技术检查：**

- [ ] 未使用Swagger文档工具
- [ ] 未使用Redis缓存
- [ ] 未使用MyBatis系列
- [ ] 未使用其他数据库(仅MySQL/MongoDB/PostgreSQL)

这样可以确保后端开发严格遵循项目的技术栈约束！