# 基于RBAC的细粒度权限系统实现方案

## 1. 系统概述

本方案实现了一套完整的RBAC（Role-Based Access Control）权限管理系统，支持从页面访问到按钮级别的细粒度权限控制。采用Spring Boot + Vue3的前后端分离架构。

### 1.1 核心特性
- **细粒度控制**：可控制到具体按钮和操作级别
- **动态权限**：支持运行时动态调整权限配置
- **层级结构**：资源支持树形层级关系
- **前后端统一**：前后端使用相同的权限模型
- **易于扩展**：新增权限只需配置资源表

### 1.2 权限控制层级
1. **接口级权限**：后端API接口访问控制
2. **页面级权限**：前端路由和菜单显示控制
3. **按钮级权限**：页面内具体操作按钮显示控制

## 2. 数据库设计

### 2.1 核心表结构

#### 角色表 (tb_role2)
```sql
CREATE TABLE tb_role2 (
    id VARCHAR(40) PRIMARY KEY COMMENT '主键ID',
    customer_id VARCHAR(50) NOT NULL COMMENT '客户域',
    name VARCHAR(50) NOT NULL UNIQUE COMMENT '角色名称',
    role_code VARCHAR(100) NOT NULL UNIQUE COMMENT '角色编码',
    description VARCHAR(200) COMMENT '角色描述',
    create_time BIGINT(13) NOT NULL COMMENT '创建时间',
    last_update_time BIGINT(13) NOT NULL COMMENT '最后更新时间',
    can_delete INT(1) NOT NULL COMMENT '是否可以删除',
    can_modify INT(1) NOT NULL COMMENT '是否可以编辑'
);
```

#### 资源表 (tb_resource2)
```sql
CREATE TABLE tb_resource2 (
    id VARCHAR(40) PRIMARY KEY COMMENT '主键ID',
    url VARCHAR(200) COMMENT '访问路径',
    parent_id VARCHAR(40) COMMENT '上级资源ID',
    resource_name VARCHAR(100) COMMENT '资源名称',
    resource_type VARCHAR(100) COMMENT '资源类型',
    show_sort INT(10) COMMENT '显示排序',
    create_time BIGINT(13) COMMENT '创建时间',
    last_update_time BIGINT(13) COMMENT '最后更新时间',
    id_path TEXT COMMENT '层级ID路径',
    name_path TEXT COMMENT '层级名称路径',
    has_deleted INT(1) COMMENT '是否已删除',
    category_code VARCHAR(100) COMMENT '资源分类编码'
);
```

#### 角色资源关联表 (tb_role_resource2)
```sql
CREATE TABLE tb_role_resource2 (
    id VARCHAR(40) PRIMARY KEY COMMENT '主键ID',
    customer_id VARCHAR(50) NOT NULL COMMENT '客户域',
    role_id VARCHAR(36) NOT NULL COMMENT '角色ID',
    resource_id VARCHAR(36) NOT NULL COMMENT '资源ID',
    create_time BIGINT(13) NOT NULL COMMENT '创建时间',
    category_code VARCHAR(100) COMMENT '资源分类编码'
);
```

### 2.2 资源类型定义
- `top-level-navigation`：顶级导航
- `menu-grouping`：菜单分组
- `submenu`：子菜单
- `interface`：API接口
- `crud`：数据操作（增删改查）
- `page-module`：页面子模块

## 3. 后端实现

### 3.1 实体类定义

#### Role.java
```java
@Entity
@Table(name = "tb_role2")
@Data
public class Role {
    @Id
    @GeneratedValue(generator = "uuid")
    @GenericGenerator(name = "uuid", strategy = "uuid2")
    @Column(columnDefinition = "varchar(40) comment '主键id'")
    private String id;
    
    @Column(nullable = false, columnDefinition = "VARCHAR(50) COMMENT '客户域'")
    private String customerId;
    
    @Column(nullable = false, unique = true, columnDefinition = "VARCHAR(50) COMMENT '角色名称'")
    private String name;
    
    @Column(nullable = false, unique = true, columnDefinition = "VARCHAR(100) COMMENT '角色编码'")
    private String roleCode;
    
    // ... 其他字段
}
```

#### Resource.java
```java
@Entity
@Table(name = "tb_resource2")
@Data
public class Resource {
    @Id
    @GeneratedValue(generator = "uuid")
    @GenericGenerator(name = "uuid", strategy = "uuid2")
    @Column(columnDefinition = "varchar(40) comment '主键ID'")
    private String id;
    
    @Column(columnDefinition = "VARCHAR(200) COMMENT '访问路径'")
    private String url;
    
    @Column(columnDefinition = "VARCHAR(100) COMMENT '资源名称'")
    private String resourceName;
    
    @Column(columnDefinition = "VARCHAR(100) COMMENT '资源类型'")
    private String resourceType;
    
    @Transient
    private List<Resource> children;
    
    @Transient
    private Boolean hasPermission;
    
    // ... 其他字段
}
```

### 3.2 Spring Security配置

#### WebSecurityConfig.java
```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class WebSecurityConfig {
    
    @Autowired
    private CustomFilterSecurityMetadataSource metadataSource;
    
    @Autowired
    private CustomAccessDecisionManager accessDecisionManager;
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf().disable()
            .authorizeRequests()
            .antMatchers(permitPaths).permitAll()
            .anyRequest().authenticated()
            .accessDecisionManager(accessDecisionManager)
            .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {
                @Override
                public <O extends FilterSecurityInterceptor> O postProcess(O fsi) {
                    fsi.setSecurityMetadataSource(metadataSource);
                    fsi.setAccessDecisionManager(accessDecisionManager);
                    return fsi;
                }
            });
        return http.build();
    }
}
```

#### 权限元数据源 CustomFilterSecurityMetadataSource.java
```java
@Component
public class CustomFilterSecurityMetadataSource implements FilterInvocationSecurityMetadataSource {
    
    @Override
    public Collection<ConfigAttribute> getAttributes(Object object) {
        String requestUrl = ((FilterInvocation) object).getRequestUrl();
        String cleanUrl = requestUrl.contains("?") ? requestUrl.substring(0, requestUrl.indexOf("?")) : requestUrl;
        
        // 检查白名单路径
        for (String permitPath : permitPaths) {
            if (antPathMatcher.match(permitPath, cleanUrl)) {
                return null; // 白名单直接放行
            }
        }
        
        // 超级管理员检查
        if (SecurityUtil.isSystemAdministrator()) {
            return null;
        }
        
        // 普通角色权限检查
        Map<String, Set<String>> roleResourceMap = roleResourceService.loadRoleResourceMap(SecurityUtil.getCustomerId());
        for (Map.Entry<String, Set<String>> entry : roleResourceMap.entrySet()) {
            if (antPathMatcher.match(entry.getKey(), cleanUrl)) {
                Set<String> roles = entry.getValue();
                return roles.stream()
                        .map(SecurityConfig::new)
                        .collect(Collectors.toList());
            }
        }
        
        return SecurityConfig.createList("ROLE_NONE_EXISTING");
    }
}
```

#### 权限决策管理器 CustomAccessDecisionManager.java
```java
@Component
public class CustomAccessDecisionManager implements AccessDecisionManager {
    
    @Override
    public void decide(Authentication authentication, Object object, Collection<ConfigAttribute> configAttributes) {
        if (CollectionUtils.isEmpty(configAttributes)) {
            return; // 允许访问
        }
        
        for (ConfigAttribute attribute : configAttributes) {
            if ("ROLE_NONE_EXISTING".equals(attribute.getAttribute())) {
                throw new AccessDeniedException("Access denied");
            }
            
            for (GrantedAuthority authority : authentication.getAuthorities()) {
                if (attribute.getAttribute().equals(authority.getAuthority())) {
                    return; // 权限匹配，允许访问
                }
            }
        }
        
        throw new AccessDeniedException("No permission");
    }
}
```

## 4. 前端实现

### 4.1 状态管理 - userStore.js
```javascript
import { defineStore } from 'pinia'

export const useUserStore = defineStore('user', {
  state: () => ({
    token: localStorage.getItem('token') || '',
    role: localStorage.getItem('role') || '',
    username: localStorage.getItem('username') || '', 
    systemResource: JSON.parse(localStorage.getItem('systemResource') || 'null'),
    roleResourceMap: JSON.parse(localStorage.getItem('roleResourceMap') || '{}'),
    authorities: JSON.parse(localStorage.getItem('authorities') || '[]')
  }),
  
  actions: {
    setSystemResource(resource) {
      this.systemResource = resource
      localStorage.setItem('systemResource', JSON.stringify(resource))
    },
    
    hasPermission(path) {
      if (!this.roleResourceMap || !path) return false
      const allowedRoles = this.roleResourceMap[path]
      return allowedRoles && allowedRoles.includes(this.role)
    }
  }
})
```

### 4.2 按钮级权限控制组件 - PermissionButton.vue
```vue
<template>
  <slot v-if="hasPermission"></slot>
</template>

<script setup>
import { computed } from 'vue'
import { useRoute } from 'vue-router'
import { useUserStore } from '@/stores/userStore'

const props = defineProps({
  permissionNameList: {
    type: Array,
    default: () => []
  }
})

const route = useRoute()
const userStore = useUserStore()

// 根据URL查找资源节点
function findResourceByUrl(resource, url) {
  if (!resource || !resource.children) return null
  for (const item of resource.children) {
    if (item.url && url.startsWith(item.url)) return item
    const found = findResourceByUrl(item, url)
    if (found) return found
  }
  return null
}

const hasPermission = computed(() => {
  const systemResource = userStore.systemResource
  const currentPath = route.path
  const currentMenu = findResourceByUrl(systemResource, currentPath)
  
  if (!currentMenu?.children) return false

  const namesToCheck = Array.isArray(props.permissionNameList) && props.permissionNameList.length > 0
    ? props.permissionNameList
    : [getSlotText()]

  return namesToCheck.some(name =>
    currentMenu.children.some(item => item.resourceName?.trim() === name)
  )
})
</script>
```

### 4.3 权限工具函数 - permission.js
```javascript
import { useUserStore } from "@/stores/user"

/**
 * 查找资源节点
 */
const findResource = (resource, names) => {
  if (names.length === 0) return resource
  const child = resource.children?.find(item => item.resourceName === names[0])
  return child ? findResource(child, names.slice(1)) : null
}

/**
 * 检查用户是否具有指定权限
 */
export const hasPermission = (path, permissionName) => {
  const userStore = useUserStore()
  const systemResource = userStore.systemResource
  if (!systemResource || !systemResource.children) return false

  const resource = findResource(systemResource, path.split("/"))
  if (!resource || !resource.children) return false

  return resource.children.some(item => item.resourceName === permissionName)
}

/**
 * 获取权限对象
 */
export const getPermissions = (path) => {
  const userStore = useUserStore()
  const systemResource = userStore.systemResource
  if (!systemResource || !systemResource.children) return {}

  const resource = findResource(systemResource, path.split("/"))
  if (!resource || !resource.children) return {}

  return {
    add: resource.children.some(item => item.resourceName === "新增"),
    import: resource.children.some(item => item.resourceName === "导入"),
    export: resource.children.some(item => item.resourceName === "导出"),
    edit: resource.children.some(item => item.resourceName === "编辑"),
    delete: resource.children.some(item => item.resourceName === "删除"),
    viewDetails: resource.children.some(item => item.resourceName === "查看详情")
  }
}
```

## 5. 开发流程

### 5.1 权限配置流程

1. **定义资源结构**
   - 在资源表中创建页面、菜单、按钮等资源
   - 设置资源的层级关系（parent_id）
   - 定义资源类型和访问路径

2. **创建角色**
   - 在角色表中定义系统角色
   - 设置角色编码和描述

3. **分配权限**
   - 在角色资源关联表中建立角色与资源的关系
   - 支持批量权限分配

### 5.2 前端开发流程

1. **页面级权限**
   ```javascript
   // 在路由配置中使用
   {
     path: '/user-management',
     component: UserManagement,
     meta: { 
       requiresAuth: true,
       permission: '用户管理'
     }
   }
   ```

2. **按钮级权限**
   ```vue
   <template>
     <PermissionButton>
       <el-button type="primary">新增用户</el-button>
     </PermissionButton>
     
     <PermissionButton :permission-name-list="['编辑']">
       <el-button type="warning">编辑</el-button>
     </PermissionButton>
   </template>
   ```

3. **函数式权限检查**
   ```javascript
   import { hasPermission, getPermissions } from '@/utils/permission'
   
   // 检查单个权限
   const canAdd = hasPermission('用户管理/用户列表', '新增')
   
   // 获取所有权限
   const permissions = getPermissions('用户管理/用户列表')
   console.log(permissions.add, permissions.edit, permissions.delete)
   ```

### 5.3 后端开发流程

1. **Controller权限注解**
   ```java
   @RestController
   @RequestMapping("/api/users")
   public class UserController {
       
       @GetMapping("/list")
       @PreAuthorize("hasRole('USER_VIEW')")
       public ResponseEntity<?> getUserList() {
           // 用户列表查询
       }
       
       @PostMapping("/add")
       @PreAuthorize("hasRole('USER_ADD')")
       public ResponseEntity<?> addUser(@RequestBody User user) {
           // 新增用户
       }
   }
   ```

2. **服务层权限控制**
   ```java
   @Service
   public class UserService {
       
       public List<User> getUserList() {
           // 根据当前用户权限过滤数据
           String currentUserId = SecurityUtil.getCurrentUserId();
           return userRepository.findByPermission(currentUserId);
       }
   }
   ```

## 6. 使用示例

### 6.1 完整页面权限控制示例

```vue
<template>
  <div>
    <!-- 页面标题 -->
    <h1>用户管理</h1>
    
    <!-- 操作按钮区域 -->
    <div class="action-bar">
      <PermissionButton>
        <el-button type="primary" @click="handleAdd">新增用户</el-button>
      </PermissionButton>
      
      <PermissionButton :permission-name-list="['导入']">
        <el-button type="success" @click="handleImport">导入用户</el-button>
      </PermissionButton>
      
      <PermissionButton :permission-name-list="['导出']">
        <el-button type="info" @click="handleExport">导出用户</el-button>
      </PermissionButton>
    </div>
    
    <!-- 数据表格 -->
    <el-table :data="userList">
      <el-table-column prop="username" label="用户名"></el-table-column>
      <el-table-column prop="email" label="邮箱"></el-table-column>
      <el-table-column label="操作">
        <template #default="{ row }">
          <PermissionButton :permission-name-list="['编辑']">
            <el-button size="small" @click="handleEdit(row)">编辑</el-button>
          </PermissionButton>
          
          <PermissionButton :permission-name-list="['删除']">
            <el-button size="small" type="danger" @click="handleDelete(row)">删除</el-button>
          </PermissionButton>
        </template>
      </el-table-column>
    </el-table>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { getPermissions } from '@/utils/permission'

const userList = ref([])
const permissions = ref({})

onMounted(async () => {
  // 获取页面权限
  permissions.value = getPermissions('基础信息管理/用户管理/用户列表')
  
  // 根据权限加载数据
  if (permissions.value.viewDetails) {
    await loadUserList()
  }
})

const loadUserList = async () => {
  // 加载用户列表数据
}

const handleAdd = () => {
  // 新增用户逻辑
}
</script>
```

### 6.2 资源配置示例

```sql
-- 基础信息管理（顶级导航）
INSERT INTO tb_resource2 (id, resource_name, resource_type, category_code) 
VALUES ('base-info-mgmt', '基础信息管理', 'top-level-navigation', 'web');

-- 用户管理（菜单分组）
INSERT INTO tb_resource2 (id, parent_id, resource_name, resource_type, category_code) 
VALUES ('user-mgmt', 'base-info-mgmt', '用户管理', 'menu-grouping', 'web');

-- 用户列表（子菜单）
INSERT INTO tb_resource2 (id, parent_id, resource_name, url, resource_type, category_code) 
VALUES ('user-list', 'user-mgmt', '用户列表', '/user-management', 'submenu', 'web');

-- 具体操作权限
INSERT INTO tb_resource2 (id, parent_id, resource_name, resource_type, category_code) 
VALUES 
('user-add', 'user-list', '新增', 'crud', 'web'),
('user-edit', 'user-list', '编辑', 'crud', 'web'),
('user-delete', 'user-list', '删除', 'crud', 'web'),
('user-import', 'user-list', '导入', 'crud', 'web'),
('user-export', 'user-list', '导出', 'crud', 'web');
```

## 7. 最佳实践

### 7.1 权限命名规范
- 页面级权限：使用中文描述，如"用户管理"、"订单查询"
- 操作级权限：使用标准动词，如"新增"、"编辑"、"删除"、"查看详情"
- 接口权限：使用ROLE_前缀，如"ROLE_USER_ADD"、"ROLE_ORDER_VIEW"

### 7.2 性能优化
- 权限数据缓存：用户登录后将权限树缓存到localStorage
- 延迟加载：大型权限树支持按需加载子节点
- 批量权限检查：避免频繁的单个权限检查

### 7.3 安全注意事项
- 前端权限控制仅用于用户体验优化，安全控制必须在后端实现
- 敏感操作必须进行二次权限验证
- 定期清理无效的权限配置和角色

### 7.4 维护建议
- 建立权限变更审批流程
- 定期进行权限清理和优化
- 提供权限管理的可视化界面
- 记录权限变更日志

## 8. 总结

这套权限系统通过RBAC模型实现了从接口到按钮的细粒度权限控制，具有以下优势：

1. **架构清晰**：前后端权限模型统一，易于理解和维护
2. **功能完善**：支持动态权限配置和层级权限管理
3. **易于扩展**：新增功能只需配置相应的资源即可
4. **性能优良**：通过缓存和优化减少权限检查开销

该方案适用于中大型企业级应用，能够满足复杂的权限管理需求。在实际项目中应用时，可根据具体业务需求进行适当调整和扩展。